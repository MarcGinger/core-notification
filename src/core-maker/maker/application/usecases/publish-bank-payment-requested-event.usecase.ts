import {
  BadRequestException,
  Inject,
  Injectable,
  Logger,
  UnauthorizedException,
} from '@nestjs/common';
import { handleCommandError } from 'src/shared/application/commands';
import { IntegrationBus } from 'src/shared/integration/integration-bus.port';
import { IntegrationEvent } from 'src/shared/integration/integration-event';
import { IUserToken } from '../../../../shared/auth';
import { CoreMakerLoggingHelper } from '../../../shared/domain/value-objects';
import {
  CreateMakerProps,
  IMaker,
  MakerDomainService,
  MakerExceptionMessage,
} from '../../domain';
import { MakerRepository } from '../../infrastructure/repositories';

@Injectable()
export class PublishBankPaymentRequestedEventUseCase {
  private readonly logger = new Logger(
    PublishBankPaymentRequestedEventUseCase.name,
  );

  constructor(
    private readonly repository: MakerRepository,
    private readonly domainService: MakerDomainService,
    @Inject('IntegrationBus') private readonly integrationBus: IntegrationBus,
  ) {}

  async execute(user: IUserToken, props: CreateMakerProps): Promise<IMaker> {
    // Single operation start log with all context
    // Single operation start log
    const operationContext = CoreMakerLoggingHelper.createEnhancedLogContext(
      'PublishBankPaymentRequestedEventUseCase',
      'execute',
      undefined, // UUID will be generated by the domain service
      user,
      {
        operation: 'CREATE',
        entityType: 'maker',
        phase: 'START',
        hasUser: !!user,
        hasProps: !!props,
        propsFields: props ? Object.keys(props).length : 0,
        userTenant: user?.tenant,
      },
    );

    this.logger.log(
      operationContext,
      `Starting maker creation: 'primary-key (uuid())'`,
    );

    try {
      // Input validation (no logging unless error)
      this.validateInput(user, props);

      // Domain service interaction (single log for business operation)
      this.logger.log(
        operationContext,
        `Invoking domain service for maker creation: primary-key (uuid())`,
      );

      // Create aggregate and track events
      const aggregate = await this.domainService.createMaker(user, props);
      const eventsEmitted = aggregate.getUncommittedEvents();

      // Prepare integration event
      const event: IntegrationEvent = {
        type: 'bank.payment.requested.v1',
        version: 1,
        eventId: crypto.randomUUID(),
        correlationId: `maker-${aggregate.getId()}`,
        tenantId: user.tenant,
        idempotencyKey: `maker:${aggregate.getId()}`,
        occurredAt: new Date().toISOString(),
        payload: props,
        headers: { source: 'MakerModule' },
        context: {
          actor: {
            type: 'user',
            ...user,
          },
        },
      };

      // Persist aggregate and outbox event atomically
      const result = await this.repository.saveMakerWithOutbox(
        user,
        aggregate,
        event,
      );

      // Single success log with comprehensive summary
      const successContext = CoreMakerLoggingHelper.createEnhancedLogContext(
        'PublishBankPaymentRequestedEventUseCase',
        'execute',
        result.id,
        user,
        {
          operation: 'CREATE',
          entityType: 'maker',
          phase: 'SUCCESS',
          createdCode: result.id,
          eventsCommitted: eventsEmitted.length,
          eventTypes: eventsEmitted.map((e) => e.constructor.name),
        },
      );

      this.logger.log(
        successContext,
        `Successfully created maker and persisted outbox event: ${result.id} [events: ${eventsEmitted.length}]`,
      );

      return result;
    } catch (error) {
      // Single error log with context
      const errorContext = CoreMakerLoggingHelper.createEnhancedLogContext(
        'PublishBankPaymentRequestedEventUseCase',
        'execute',
        undefined,
        user,
        {
          operation: 'CREATE',
          entityType: 'maker',
          phase: 'ERROR',
          errorType:
            error instanceof Error ? error.constructor.name : 'Unknown',
          errorMessage:
            error instanceof Error ? error.message : 'Unknown error',
          inputProps: props ? Object.keys(props) : [],
        },
      );

      this.logger.error(
        errorContext,
        `Maker creation failed: primary-key (uuid())`,
      );

      // Centralized error handling for domain and infra errors
      handleCommandError(error, null, MakerExceptionMessage.createError);
      throw error;
    }
  }

  /**
   * Input validation for publish-maker-event
   */
  private validateInput(user: IUserToken, payload: CreateMakerProps): void {
    if (!user) {
      this.logger.warn(
        CoreMakerLoggingHelper.createEnhancedLogContext(
          'PublishMakerEventUseCase',
          'validateInput',
          'unknown',
          undefined,
          {
            operation: 'PUBLISH',
            entityType: 'maker',
            validationError: 'missing_user',
          },
        ),
        'Maker event publish attempted without user authentication',
      );
      throw new UnauthorizedException('User required to publish maker event');
    }
    if (!payload) {
      this.logger.warn(
        CoreMakerLoggingHelper.createEnhancedLogContext(
          'PublishMakerEventUseCase',
          'validateInput',
          'unknown',
          user,
          {
            operation: 'PUBLISH',
            entityType: 'maker',
            validationError: 'missing_payload',
          },
        ),
        'Maker event publish attempted without payload',
      );
      throw new BadRequestException('payload required to publish maker event');
    }
  }
}
