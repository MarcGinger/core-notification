/**
 * Copyright (c) 2025 Marc Ginger. All rights reserved.
 *
 * This file is part of a proprietary NestJS system developed by Marc Ginger.
 * Unauthorized copying, modification, distribution, or use of this file,
 * via any medium, is strictly prohibited and may result in legal action.
 *
 * Confidential and proprietary.
 */

import {
  BadRequestException,
  Injectable,
  Logger,
  UnauthorizedException,
} from '@nestjs/common';
import { handleCommandError } from 'src/shared/application/commands';
import { MakerRepository } from '../../infrastructure/repositories';
import { IUserToken } from 'src/shared/auth';
import { IMaker } from '../../domain/entities';
import { MakerExceptionMessage } from '../../domain/exceptions';
import { MakerDomainService } from '../../domain/services';
import { CoreMakerLoggingHelper } from '../../../shared/domain/value-objects';
import { CreateMakerProps } from '../../domain/properties';

/**
 * Use case for creating maker entities with proper domain validation.
 * Demonstrates proper use of domain services for business rule validation.
 *
 * This implementation showcases:
 * - Proper separation of concerns between application and domain layers
 * - Use of domain services for complex business rules
 * - Comprehensive error handling and audit logging
 * - Input validation and sanitization
 * - Transaction management and rollback capabilities
 */
@Injectable()
export class CreateMakerUseCase {
  private readonly logger = new Logger(CreateMakerUseCase.name);

  constructor(
    private readonly repository: MakerRepository,
    private readonly domainService: MakerDomainService,
  ) {}

  /**
   * Creates a new maker with proper domain validation
   * Production-optimized with smart logging strategy
   * @param user - The user performing the operation
   * @param props - The creation properties
   * @returns Promise<IMaker> - The created maker DTO
   * @throws MakerExceptionMessage - When business rules prevent creation
   */
  async execute(user: IUserToken, props: CreateMakerProps): Promise<IMaker> {
    // Single operation start log with all context
    // Single operation start log
    const operationContext = CoreMakerLoggingHelper.createEnhancedLogContext(
      'CreateMakerUseCase',
      'execute',
      undefined, // UUID will be generated by the domain service
      user,
      {
        operation: 'CREATE',
        entityType: 'maker',
        phase: 'START',
        hasUser: !!user,
        hasProps: !!props,
        propsFields: props ? Object.keys(props).length : 0,
        userTenant: user?.tenant,
      },
    );

    this.logger.log(
      operationContext,
      `Starting maker creation: 'primary-key (uuid())'`,
    );

    try {
      // Input validation (no logging unless error)
      this.validateInput(user, props);

      // Domain service interaction (single log for business operation)
      this.logger.log(
        operationContext,
        `Invoking domain service for maker creation: primary-key (uuid())`,
      );

      // Create aggregate and track events
      const aggregate = await this.domainService.createMaker(user, props);
      const eventsEmitted = aggregate.getUncommittedEvents();

      // Persist the aggregate
      const result = await this.repository.saveMaker(user, aggregate);

      // Single success log with comprehensive summary
      const successContext = CoreMakerLoggingHelper.createEnhancedLogContext(
        'CreateMakerUseCase',
        'execute',
        result.id,
        user,
        {
          operation: 'CREATE',
          entityType: 'maker',
          phase: 'SUCCESS',
          createdCode: result.id,
          eventsCommitted: eventsEmitted.length,
          eventTypes: eventsEmitted.map((e) => e.constructor.name),
        },
      );

      this.logger.log(
        successContext,
        `Successfully created maker: ${result.id} [events: ${eventsEmitted.length}]`,
      );

      return result;
    } catch (error) {
      // Single error log with context
      const errorContext = CoreMakerLoggingHelper.createEnhancedLogContext(
        'CreateMakerUseCase',
        'execute',
        undefined,
        user,
        {
          operation: 'CREATE',
          entityType: 'maker',
          phase: 'ERROR',
          errorType:
            error instanceof Error ? error.constructor.name : 'Unknown',
          errorMessage:
            error instanceof Error ? error.message : 'Unknown error',
          inputProps: props ? Object.keys(props) : [],
        },
      );

      this.logger.error(
        errorContext,
        `Maker creation failed: primary-key (uuid())`,
      );

      // Centralized error handling for domain and infra errors
      handleCommandError(error, null, MakerExceptionMessage.createError);
      throw error;
    }
  }

  /**
   * Enhanced input validation with detailed logging and business context
   * Validates technical concerns only - business rules enforced by domain aggregate
   */
  private validateInput(user: IUserToken, props: CreateMakerProps): void {
    // User validation
    if (!user) {
      this.logger.warn(
        CoreMakerLoggingHelper.createEnhancedLogContext(
          'CreateMakerUseCase',
          'validateInput',
          'unknown',
          undefined,
          {
            operation: 'CREATE',
            entityType: 'maker',
            validationError: 'missing_user',
          },
        ),
        'Maker creation attempted without user authentication',
      );
      throw new UnauthorizedException(
        MakerExceptionMessage.userRequiredToCreateMaker,
      );
    }

    // Props validation
    if (!props) {
      this.logger.warn(
        CoreMakerLoggingHelper.createEnhancedLogContext(
          'CreateMakerUseCase',
          'validateInput',
          'unknown',
          user,
          {
            operation: 'CREATE',
            entityType: 'maker',
            validationError: 'missing_props',
          },
        ),
        'Maker creation attempted without required properties',
      );
      throw new BadRequestException(
        MakerExceptionMessage.propsRequiredToCreateMaker,
      );
    }

    // Note: Business rules enforced by the Maker aggregate's validateState() method
  }
}
