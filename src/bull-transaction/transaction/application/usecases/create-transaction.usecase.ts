/**
 * Copyright (c) 2025 Marc Ginger. All rights reserved.
 *
 * This file is part of a proprietary NestJS system developed by Marc Ginger.
 * Unauthorized copying, modification, distribution, or use of this file,
 * via any medium, is strictly prohibited and may result in legal action.
 *
 * Confidential and proprietary.
 */

import {
  BadRequestException,
  Injectable,
  Logger,
  UnauthorizedException,
} from '@nestjs/common';
import { handleCommandError } from 'src/shared/application/commands';
import { TransactionRepository } from '../../infrastructure/repositories';
import { IUserToken } from 'src/shared/auth';
import { ITransaction } from '../../domain/entities';
import { TransactionExceptionMessage } from '../../domain/exceptions';
import { TransactionDomainService } from '../../domain/services';
import { BullTransactionLoggingHelper } from '../../../shared/domain/value-objects';
import { CreateTransactionProps } from '../../domain/properties';

/**
 * Use case for creating transaction entities with proper domain validation.
 * Demonstrates proper use of domain services for business rule validation.
 *
 * This implementation showcases:
 * - Proper separation of concerns between application and domain layers
 * - Use of domain services for complex business rules
 * - Comprehensive error handling and audit logging
 * - Input validation and sanitization
 * - Transaction management and rollback capabilities
 */
@Injectable()
export class CreateTransactionUseCase {
  private readonly logger = new Logger(CreateTransactionUseCase.name);

  constructor(
    private readonly repository: TransactionRepository,
    private readonly domainService: TransactionDomainService,
  ) {}

  /**
   * Creates a new transaction with proper domain validation
   * Production-optimized with smart logging strategy
   * @param user - The user performing the operation
   * @param props - The creation properties
   * @returns Promise<ITransaction> - The created transaction DTO
   * @throws TransactionExceptionMessage - When business rules prevent creation
   */
  async execute(
    user: IUserToken,
    props: CreateTransactionProps,
  ): Promise<ITransaction> {
    // Single operation start log with all context
    // Single operation start log
    const operationContext =
      BullTransactionLoggingHelper.createEnhancedLogContext(
        'CreateTransactionUseCase',
        'execute',
        undefined, // UUID will be generated by the domain service
        user,
        {
          operation: 'CREATE',
          entityType: 'transaction',
          phase: 'START',
          hasUser: !!user,
          hasProps: !!props,
          propsFields: props ? Object.keys(props).length : 0,
          userTenant: user?.tenant,
        },
      );

    this.logger.log(
      operationContext,
      `Starting transaction creation: 'primary-key (uuid())'`,
    );

    try {
      // Input validation (no logging unless error)
      this.validateInput(user, props);

      // Domain service interaction (single log for business operation)
      this.logger.log(
        operationContext,
        `Invoking domain service for transaction creation: primary-key (uuid())`,
      );

      // Create aggregate and track events
      const aggregate = await this.domainService.createTransaction(user, props);
      const eventsEmitted = aggregate.getUncommittedEvents();

      // Persist the aggregate
      const result = await this.repository.saveTransaction(user, aggregate);

      // Single success log with comprehensive summary
      const successContext =
        BullTransactionLoggingHelper.createEnhancedLogContext(
          'CreateTransactionUseCase',
          'execute',
          result.id,
          user,
          {
            operation: 'CREATE',
            entityType: 'transaction',
            phase: 'SUCCESS',
            createdCode: result.id,
            eventsCommitted: eventsEmitted.length,
            eventTypes: eventsEmitted.map((e) => e.constructor.name),
          },
        );

      this.logger.log(
        successContext,
        `Successfully created transaction: ${result.id} [events: ${eventsEmitted.length}]`,
      );

      return result;
    } catch (error) {
      // Single error log with context
      const errorContext =
        BullTransactionLoggingHelper.createEnhancedLogContext(
          'CreateTransactionUseCase',
          'execute',
          undefined,
          user,
          {
            operation: 'CREATE',
            entityType: 'transaction',
            phase: 'ERROR',
            errorType:
              error instanceof Error ? error.constructor.name : 'Unknown',
            errorMessage:
              error instanceof Error ? error.message : 'Unknown error',
            inputProps: props ? Object.keys(props) : [],
          },
        );

      this.logger.error(
        errorContext,
        `Transaction creation failed: primary-key (uuid())`,
      );

      // Centralized error handling for domain and infra errors
      handleCommandError(error, null, TransactionExceptionMessage.createError);
      throw error;
    }
  }

  /**
   * Enhanced input validation with detailed logging and business context
   * Validates technical concerns only - business rules enforced by domain aggregate
   */
  private validateInput(user: IUserToken, props: CreateTransactionProps): void {
    // User validation
    if (!user) {
      this.logger.warn(
        BullTransactionLoggingHelper.createEnhancedLogContext(
          'CreateTransactionUseCase',
          'validateInput',
          'unknown',
          undefined,
          {
            operation: 'CREATE',
            entityType: 'transaction',
            validationError: 'missing_user',
          },
        ),
        'Transaction creation attempted without user authentication',
      );
      throw new UnauthorizedException(
        TransactionExceptionMessage.userRequiredToCreateTransaction,
      );
    }

    // Props validation
    if (!props) {
      this.logger.warn(
        BullTransactionLoggingHelper.createEnhancedLogContext(
          'CreateTransactionUseCase',
          'validateInput',
          'unknown',
          user,
          {
            operation: 'CREATE',
            entityType: 'transaction',
            validationError: 'missing_props',
          },
        ),
        'Transaction creation attempted without required properties',
      );
      throw new BadRequestException(
        TransactionExceptionMessage.propsRequiredToCreateTransaction,
      );
    }

    // Note: Business rules enforced by the Transaction aggregate's validateState() method
  }
}
